#!/usr/bin/perl -w

package htrosbif;

use Getopt::Long;
use Pod::Usage;
use Test::Deep::NoTest;
use URI;
use strict;

=encoding utf8

=head1 NAME

htrosbif - Active HTTP fingerprinting and recon tool

=head1 SYNOPSIS

htrosbif [-v|--verbose] [-d|--debug <num>] [--timeout <seconds>] url

htrosbif [-?|-h|--help]

=head1 DESCRIPTION

Does a bit of Recon by Fire, if you will. Prods the web server in all sorts of old, new, basic, fancy, spec-compliant and spec-breaking ways. Tries to characterise both the well-spoken educated responses and the seriously deviant babble it receives in return.

Fingerprint-matching still to be implemented. But fingerprinting is.

=head1 AUTHOR

Erik Inge Bols√∏ <knan-rosbif@anduin.net> originally wrote this tool.

=cut

my $verbose;
my $debug;
my $resptimeout = 2;
my $mediumtimeout = 7;
my $help = 0;
my $result;

# blandest possible but still plausible useragent
my $bland_useragent = 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)' ;

$result = GetOptions (	'verbose|v' => \$verbose,
			'timeout=i' => \$resptimeout,
			'debug|d=i' => \$debug,
                      	'help|h|?'  => \$help);

pod2usage(-exitstatus=>0, -verbose=>2) if $help;

my $url = $ARGV[0] || "http://127.0.0.1:8080/";
my $uri = URI->new($url);
my $host = $uri->host;
my $port = $uri->port;
my $path = $uri->path;
my $scheme = $uri->scheme;

my %testresults;
my $tmpresult;

# XXX: actually, no https yet.
unless ($scheme eq "http" or $scheme eq "https") { die "only supports http and https URI schemes, for now.\n" ; }

# is_namevhost();

# friendly requests, should mostly work
$tmpresult = &test_get_09_knowngood(); add_testresult('get_09_knowngood', $tmpresult );
$tmpresult = &test_get_10_knowngood(); add_testresult('get_10_knowngood', $tmpresult );
$tmpresult = &test_get_11_knowngood(); add_testresult('get_11_knowngood', $tmpresult );

# borderline requests
$tmpresult = &test_get_12_knowngood(); add_testresult('get_12_knowngood', $tmpresult );

# error-provoking requests
$tmpresult = &test_get_20_knowngood(); add_testresult('get_20_knowngood', $tmpresult );

# evil requests
# (none yet)

# dump results
if ($verbose and %testresults) {
  print "\n";
  print "test results:\n" ;
  foreach (sort keys %testresults) {
    print "$_:\n\n";
    my $tmphashref = $testresults{$_} ;
    foreach my $sigkey (sort keys %$tmphashref) {
       print " $sigkey: $tmphashref->{ $sigkey }\n";
    }
  print "\n";
  }
}

sub add_testresult
{
  my $sigkeyname = $_[0];
  my $signature  = $_[1];

  # compress identical results into one result + references
  # max one extra level of indirection, shouldn't slow anything down

  TESTRES: foreach (sort keys %testresults) {
    my $tmphashref = $testresults{$_} ;
    unless ( $tmphashref->{ 'identical_to' } )
    {
       my $equal = eq_deeply ( $tmphashref, $signature );
       if ($equal)
       {
         $signature = { 'identical_to' => $_ } ;
         last TESTRES;
       }
    }
  }
  $testresults{$sigkeyname} = $signature ;
}

sub test_get_09_knowngood()
{
  # tests a 1991-style "GET /" request
  # we get lots of fun, illuminating responses to this one these days...
  # my favourite so far is the wonderful oxymoron "HTTP/0.9 200 OK"

  my $request   = "GET $path\r\n";
  my $request2  = "GET $path\r\n\r\n";

  if ($debug) { print "test_get_09_knowngood() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if ($#data == -1)
  {
    delete $signature{'does_keepalive'} if exists $signature{'does_keepalive'};
    @data = helper_talk($request2, $sigref);
    unless ($#data == -1)
    {
      $signature{'http09_needcrlfcrlf'} = 1;
    }
  }

  unless ($#data == -1)
  {
    if ($debug) {
      print "test_get_09_knowngood returned data (if any):\n" ;
      foreach (join '',@data) {
        print "$_\n";
      }
    }

    my $sigref2 = classify_signature(@data);
    my @sig2keys = keys %$sigref2;
    if ($#sig2keys > -1)
    {
      $signature{'http09_returnsheaders'} = 1;
      %signature = ( %signature, %$sigref2 );
    }
    else { $signature{'http09_valid'} = 1; }
  }
  else
  {
    $signature{'http09_nodata'} = 1;
  }
  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http_unexpected_keepalive'} = 1;
  }
  return $sigref;
}

sub is_namevhost()
{
  # XXX: implement me
  # tests HTTP/1.0 request with and without host header, compares returned data
}

sub test_get_10_knowngood()
{
  # tests a plain HTTP/1.0 request with Host header and a bland User-Agent.
  # no Accept: headers, in order to see default values.
  my $request  = "GET $path HTTP/1.0\r\n";
     $request .= "Host: $host\r\n";
     $request .= "User-Agent: $bland_useragent\r\n";
     $request .= "\r\n";

  if ($debug) { print "test_get_10_knowngood() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if ($debug and @data) {
    print "test_get_10_knowngood() returned data (if any):\n" ;
    foreach (join '',@data) {
      print "$_\n";
    }
  }
  my $sigref2 = classify_signature(@data);
  %signature = ( %signature, %$sigref2 );
  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http_unexpected_keepalive'} = 1;
  }
  return $sigref;
}

sub test_get_11_knowngood()
{
  # tests a plain HTTP/1.1 request with Host header and a bland User-Agent.
  # no Accept: headers, in order to see default values.
  # Connection: close, for convenience.
  my $request  = "GET $path HTTP/1.1\r\n";
     $request .= "Host: $host\r\n";
     $request .= "User-Agent: $bland_useragent\r\n";
     $request .= "Connection: close\r\n";
     $request .= "\r\n";

  if ($debug) { print "test_get_11_knowngood() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if ($debug and @data) {
    print "test_get_11_knowngood() returned data (if any):\n" ;
    foreach (join '',@data) {
      print "$_\n";
    }
  }
  my $sigref2 = classify_signature(@data);
  %signature = ( %signature, %$sigref2 );
  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http11_ignores_connection_close'} = 1;
  }
  return $sigref;
}

sub test_get_12_knowngood()
{
  # test_get_11_knowngood() with http version changed to 1.2, to test handling of unknown minor http versions
  #  some servers fall back to talking 1.1, some to 1.0
  my $request  = "GET $path HTTP/1.2\r\n";
     $request .= "Host: $host\r\n";
     $request .= "User-Agent: $bland_useragent\r\n";
     $request .= "Connection: close\r\n";
     $request .= "\r\n";

  if ($debug) { print "test_get_12_knowngood() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if ($debug and @data) {
    print "test_get_12_knowngood() returned data (if any):\n" ;
    foreach (join '',@data) {
      print "$_\n";
    }
  }
  my $sigref2 = classify_signature(@data);
  %signature = ( %signature, %$sigref2 );
  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http_unexpected_keepalive'} = 1;
  }
  return $sigref;
}

sub test_get_20_knowngood()
{
  # test_get_11_knowngood() with http version changed to 2.0, to test handling of unknown major http versions
  my $request  = "GET $path HTTP/2.0\r\n";
     $request .= "Host: $host\r\n";
     $request .= "User-Agent: $bland_useragent\r\n";
     $request .= "Connection: close\r\n";
     $request .= "\r\n";

  if ($debug) { print "test_get_20_knowngood() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if ($debug and @data) {
    print "test_get_20_knowngood() returned data (if any):\n" ;
    foreach (join '',@data) {
      print "$_\n";
    }
  }
  my $sigref2 = classify_signature(@data);
  %signature = ( %signature, %$sigref2 );
  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http_unexpected_keepalive'} = 1;
  }
  return $sigref;
}

# helper, opening/closing connection and doing non-blocking i/o
sub helper_talk
{
  my @data;
  my $blarg;
  my $sigref = $_[1] ;
 
  use IO::Socket;
  my $sock = new IO::Socket::INET ( PeerAddr => $host, PeerPort => $port, Proto => 'tcp' );
  $sock->blocking(0);

  die "Could not create socket: $!\n" unless $sock;
  
  print $sock $_[0];

  my $rin = '';
  vec($rin,fileno($sock),1) = 1;

  my ($nfound,$timeleft) = select(my $rout=$rin, undef, undef, $mediumtimeout);

  if ($nfound)
  {
    while ($nfound and read $sock, $blarg, 5000000)
    {
      push @data, $blarg;
      vec($rin,fileno($sock),1) = 1;
      ($nfound,$timeleft) = select(my $rout=$rin, undef, undef, $mediumtimeout);
    }
  };

  unless ($nfound)
  {
    $sigref->{'does_keepalive'} = 1; # which is mostly unexpected for our tests.
  }

  close($sock);

  return @data;
}

# the meaty big analysis routine
sub classify_signature()
{
  my @data = (@_) ;
  my @lines;
  my %signature ;
  my $sigref = \%signature ;
  my $linenum = 0 ;
  my @headers;

  @data = ( join '', @data ) ;

  while (@data)
  {
    my @tmp = split /\n/, pop @data ;
    @lines = (@lines, @tmp) ;
  }

  # preprocessing: do header line folding, cut everything after the header
  my @linestmp;
  LINEPRE: foreach my $line (@lines)
  {
    my $tmp = $/ ;
    $/ = "\r" ;
    chomp $line ;
    $/ = $tmp ;

#    if ($#linestmp == -1 and ( not ($line =~ m|^[Hh][Tt][Tt][Pp]/\d\.\d|)) and ($line =~ /\S+/))
#    {
#      last LINEPRE; # content before HTTP response - no headers - HTTP/0.9 GET?
#    }

    if ($line =~ /^\s+(\S+)/)
    {
      print "classify preprocessing: folding line '$line' into previous\n" if $debug;
      $linestmp[$#linestmp] = $linestmp[$#linestmp] . $1 ;
    }

    if ($#linestmp > 1 and $line =~ /^$/)
    {
      last LINEPRE; # crlfcrlf - end of headers
    }
    push @linestmp, $line;
  }
  @lines = @linestmp ;

  # analysis
  LINE: foreach my $line (@lines)
  {
    $linenum++;

    # check for overeager 100 Continue ... sent after seeing the request line and before seeing the headers.
    # Jetty 2.4 does this. It then reads the headers, and follows up sending a full response.
    # A mildly strange interpretation of RFC2068. Probably led to the multiple paragraphs of clarifications
    # in RFC2616.
    if ($line =~ m|^([Hh][Tt][Tt][Pp])/(1\.1) 100| and not exists $signature{'http'} and not exists $signature{'temp_http'})
    {
      $signature{'temp_http'} = $1;
      $signature{'temp_http_version'} = $2;

      if ($line =~ m|^[Hh][Tt][Tt][Pp]/\d\.\d(\s+)(\d{3})(\s+)(.+)| )
      {
        $signature{'temp_response_code'} = $2;
        $signature{'temp_response_text'} = $4;
        unless ($1 eq " ") { $signature{'temp_quirk_http_to_responsecode_whitespace'} = $1; }
        unless ($3 eq " ") { $signature{'temp_quirk_responsecode_to_responsetext_whitespace'} = $3; }
      }
      next LINE;
    }

    # look for the http response
    if ($line =~ m|^([Hh][Tt][Tt][Pp])/(\d\.\d)| and not exists $signature{'http'})
    {
      $signature{'http'} = $1;
      $signature{'http_version'} = $2;

      if ($line =~ m|^[Hh][Tt][Tt][Pp]/\d\.\d(\s+)(\d{3})(\s+)(.+)| )
      {
        $signature{'response_code'} = $2;
        $signature{'response_text'} = $4;
        unless ($1 eq " ") { $signature{'quirk_http_to_responsecode_whitespace'} = $1; }
        unless ($3 eq " ") { $signature{'quirk_responsecode_to_responsetext_whitespace'} = $3; }
      }
    }

    if ($linenum == 1 and not exists $signature{'http'} and not exists $signature{'temp_http'} and $line =~ m|^\s*$|)
    {
      $signature{'quirk_whitespace_before_http_response'} = 1;
      next LINE;
    }

    # read headers
    if ($line =~ /^(\S+)( ?):( ?)(.*)/)
    {
      push @headers, $1 ;
      unless ($2 eq "") {
        my $quirkname = 'quirk_whitespace_pre_' . lc ($1);
        $signature{$quirkname} = hex $2 ;
      }
      unless ($3 eq " ") {
        my $quirkname = 'quirk_whitespace_post_' . lc ($1);
        $signature{$quirkname} = hex $3 ;
      }
    }
  }

  # list header order - may do some filtering here at some point
  if (@headers) {
    $signature{'header_order'} = join(',', @headers) ;
  }

  # overeager 100 Continue quirk
  if (exists $signature{'temp_http'} and exists $signature{'http'})
  {
    $signature{'overeager_100_continue'} = 1;
    delete $signature{'temp_http'};
    delete $signature{'temp_http_version'};
    delete $signature{'temp_response_code'};
    delete $signature{'temp_response_text'};
    delete $signature{'temp_quirk_http_to_responsecode_whitespace'};
    delete $signature{'temp_quirk_responsecode_to_responsetext_whitespace'};
  }

  # did we really get just a 100 Continue? All right.
  if (exists $signature{'temp_http'} and not exists $signature{'http'})
  {
    $signature{'http'}             = $signature{'temp_http'};          delete $signature{'temp_http'};
    $signature{'http_version'}     = $signature{'temp_http_version'};  delete $signature{'temp_http_version'};
    $signature{'response_code'}    = $signature{'temp_response_code'}; delete $signature{'temp_response_code'};
    $signature{'response_text'}    = $signature{'temp_response_text'}; delete $signature{'temp_response_text'};
    if ( exists $signature{'temp_quirk_http_to_responsecode_whitespace'} )
    {
      $signature{'quirk_http_to_responsecode_whitespace'} = $signature{'temp_quirk_http_to_responsecode_whitespace'}; delete $signature{'temp_quirk_http_to_responsecode_whitespace'};
    }
    if ( exists $signature{'temp_quirk_responsecode_to_responsetext_whitespace'} )
    {
      $signature{'quirk_responsecode_to_responsetext_whitespace'} = $signature{'temp_quirk_responsecode_to_responsetext_whitespace'}; delete $signature{'temp_quirk_responsecode_to_responsetext_whitespace'};
    }
  }

  # no http response found at all?
  # expected, for HTTP/0.9
  # mildly unexpected otherwise
  unless (exists $signature{'http'})
  {
    # grope through the data looking for error codes.
    # the server may have sent a html error page with the http response embedded. (Boa, for example.)
    FALLBACKLINE: foreach my $line (grep { m|<.+?>\d{3}.*</.+?>| } @lines)
    {
      if ($line =~ m|<.+?>(\d{3})\s*(.+?)</.+?>|)
      {
         $signature{'response_code'} = $1;
         $signature{'response_text'} = $2;
         $signature{'http_response_as_html'} = 1;
         last FALLBACKLINE;
      }
    }
  }

  return $sigref;
}

