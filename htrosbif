#!/usr/bin/perl -w

package htrosbif;

use strict;

use File::Basename;
use Getopt::Long qw(:config no_ignore_case);
use JSON::XS;
use List::MoreUtils qw(uniq);
use Pod::Usage;
use POSIX qw(floor);
use Test::Deep::NoTest;
use URI;

use constant VERSION => "alpha 2 - fuzzy" ;

=encoding utf8

=head1 NAME

htrosbif - Active HTTP fingerprinting and recon tool

=head1 SYNOPSIS

htrosbif [-v|--verbose] [-d|--debug <num>] [--timeout <seconds>] [-m|--matchsigs <signature dir>] <url>

htrosbif [-v|--verbose] [-d|--debug <num>] [--timeout <seconds>] [-w|--writesig <signature file>] <url>

htrosbif [-?|-h|--help]

htrosbif [-V|--version]

<url> should be a valid url returning a 200 series status code to a GET request - no redirect or authentication. This restriction may be lifted in the future.

=head1 DESCRIPTION

Does a bit of Recon by Fire, if you will. Prods the web server in all sorts of old, new, basic, fancy, spec-compliant and spec-breaking ways. Tries to characterise both the well-spoken educated responses and the seriously deviant babble it receives in return.

=head1 AUTHOR

Erik Inge Bols√∏ <knan-rosbif@anduin.net> originally wrote this tool.

=head1 SEE ALSO

 httprecon	<http://www.computec.ch/projekte/httprecon/>
 hmap		<http://ujeni.murkyroc.com/hmap/>

=cut

my $version;
my $verbose;
my $debug;
my $resptimeout = 2;
my $mediumtimeout = 14;
my $help = 0;
my $result;
my $writesig;
my $matchsigs = "sigs";

# blandest possible but still plausible useragent
my $bland_useragent = 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)' ;

$result = GetOptions (	'writesig|w=s' => \$writesig,
			'matchsigs|m=s'=> \$matchsigs,
			'verbose|v'    => \$verbose,
			'version|V'    => \$version,
			'timeout=i'    => \$resptimeout,
			'debug|d=i'    => \$debug,
                      	'help|h|?'     => \$help);

pod2usage(-exitstatus=>0, -verbose=>2) if $help;

if ($version)
{
  print "htrosbif " . VERSION . "\n";
  exit 0;
}

my $url = $ARGV[0] or die "No url given, nothing to do. -h for help.\n";
my $uri = URI->new($url);
my $host = $uri->host;
my $port = $uri->port;
my $path = $uri->path;
my $scheme = $uri->scheme;

my %testresults;
my $tmpresult;

my %matchresults;

my $OK_CHARS='-a-zA-Z0-9_./';
if ($writesig)
{
  if ($writesig =~ m|[^$OK_CHARS]|)
  {
    warn ("Unacceptable characters in -w filename, ignoring option\n");
    undef $writesig;
  } else {
    $writesig =~ /(.*)/;
    $writesig = $1;
    undef $matchsigs; # writesig overrides matchsigs
  }
}

if ($matchsigs)
{
  if ($matchsigs =~ m|[^$OK_CHARS]|)
  {
    warn ("Unacceptable characters in -m dirname, ignoring option\n");
    undef $matchsigs;
  } else {
    $matchsigs =~ /(.*)/;
    $matchsigs = $1;
  }
  if (! (-e $matchsigs and -d $matchsigs and -r $matchsigs) )
  {
    warn ("Signature directory '$matchsigs' not readable, ignoring -m option\n");
    undef $matchsigs;
  }
}

# XXX: actually, no https yet.
unless ($scheme eq "http" or $scheme eq "https") { die "only supports http and https URI schemes, for now.\n" ; }

# load signatures for matching
if ($matchsigs)
{
  my @sigs = <$matchsigs/*.sig> ;
  SIG: foreach my $signame (@sigs)
  {
    open SIGNAME, "<" . $signame or next SIG;
    my $sig = join '', <SIGNAME> ;
    close SIGNAME ;
    $matchresults{ basename $signame } = decode_json($sig);
  }
  if ($verbose) { print keys (%matchresults) . " signatures loaded.\n" ; }
}

print "actively fingerprinting...\n" if ($verbose) ;

# is_namevhost();

# friendly requests, should mostly work
$tmpresult = &test_get_10_knowngood(); add_testresult('get_10_knowngood', $tmpresult );
$tmpresult = &test_get_11_knowngood(); add_testresult('get_11_knowngood', $tmpresult );
$tmpresult = &test_get_09_knowngood(); add_testresult('get_09_knowngood', $tmpresult );
$tmpresult = &test_options_11_star(); add_testresult('options_11_star', $tmpresult );
$tmpresult = &test_options_11_knowngood(); add_testresult('options_11_knowngood', $tmpresult );

# borderline requests
$tmpresult = &test_get_11_headercontinuation_kind(); add_testresult('get_11_headercontinuation_kind', $tmpresult );
$tmpresult = &test_get_12_knowngood(); add_testresult('get_12_knowngood', $tmpresult );
$tmpresult = &test_get_11_headercontinuation(); add_testresult('get_11_headercontinuation', $tmpresult );

# error-provoking requests
$tmpresult = &test_get_20_knowngood(); add_testresult('get_20_knowngood', $tmpresult );

$tmpresult = &test_hairy_method_11_knowngood(); add_testresult('hairy_method_11_knowngood', $tmpresult );
$tmpresult = &test_doesnotexist_11_knowngood();
# play down the significance of the hairy_method test, mostly a small nginx quirk
if ( eq_deeply( $tmpresult, deref_sig ('hairy_method_11_knowngood', \%testresults) ) )
{
  delete $testresults{'hairy_method_11_knowngood'};
  $tmpresult->{'underscore_method_ok'} = 1;
}
add_testresult('doesnotexist_11_knowngood', $tmpresult );

# evil requests
# (none yet)

# dump results
if ($verbose and %testresults) {
  print "\n";
  print "test results:\n" ;
  foreach (sort keys %testresults) {
    print "$_:\n\n";
    my $tmphashref = $testresults{$_} ;
    foreach my $sigkey (sort keys %$tmphashref) {
       print " $sigkey: $tmphashref->{ $sigkey }\n";
    }
  print "\n";
  }
}

# signature matching
if ($matchsigs)
{
  print "doing signature matching...\n" if ($verbose) ;

  my $matches = 0;
  my %matchscores;
  my $perfectscore = 100 * keys %testresults ; 

  foreach my $sigtomatch (keys %matchresults)
  {
    if ( eq_deeply(\%testresults, $matchresults{$sigtomatch}) )
    {
      $matches++ ;
      print "Perfect match ($perfectscore): $sigtomatch\n";
      delete $matchresults{$sigtomatch};
    }
  }
  foreach my $sigtomatch (keys %matchresults)
  {
    print "fuzzy matching: comparing to $sigtomatch\n" if ($debug);
    foreach my $sigpart (keys %testresults)
    {
      my $sig1 = deref_sig ($sigpart, \%testresults);
      my $sig2 = deref_sig ($sigpart, $matchresults{$sigtomatch});

      if ( eq_deeply($sig1, $sig2))
      {
        print "fuzzy matching: perfect match on $sigpart, 100 points\n" if ($debug);
        $matchscores{$sigtomatch} += 100;
      }
      else
      {
        my $score = compare_sigs ($sig1, $sig2);
        print "fuzzy matching: partial match on $sigpart, $score points\n" if ($score > 0 and $debug);
        if ($score > 0) { $matchscores{$sigtomatch} += $score; }
      }
    }
    print "fuzzy matching: total score $matchscores{$sigtomatch}\n" if ($matchscores{$sigtomatch} > 0 and $debug);
  }
  foreach my $match (sort { $matchscores{$b} <=> $matchscores{$a} } keys %matchscores)
  {
    print "Fuzzy match ($matchscores{$match}/$perfectscore): $match\n";
  }
}

# write signature to file
if ($writesig)
{
  open SAVESIG, ">" . $writesig or die ("Couldn't open $writesig for writing signature: $!\n");
  my $savesig = JSON::XS->new->pretty(1)->encode(\%testresults);
  print SAVESIG $savesig;
  close SAVESIG;
}

exit(0);

## data handling helpers
############################

sub add_testresult
{
  my $sigkeyname = $_[0];
  my $signature  = $_[1];

  # compress identical results into one result + references
  # max one extra level of indirection, shouldn't slow anything down

  TESTRES: foreach (sort keys %testresults) {
    my $tmphashref = $testresults{$_} ;
    unless ( $tmphashref->{ 'identical_to' } )
    {
       my $equal = eq_deeply ( $tmphashref, $signature );
       if ($equal)
       {
         $signature = { 'identical_to' => $_ } ;
         last TESTRES;
       }
    }
  }
  $testresults{$sigkeyname} = $signature ;
}

sub deref_sig
{
  my $sigkeyname = $_[0];
  my $signature  = $_[1];

  my $tmpsig = $signature->{$sigkeyname};

  if ($tmpsig->{'identical_to'})
  {
    $sigkeyname = $tmpsig->{'identical_to'};
    $tmpsig = $signature->{$sigkeyname};
  }
  return $tmpsig;
}

## signature matching helpers
######################################

sub compare_sigs
{
  my $sig1 = $_[0];
  my $sig2 = $_[1];

  # FIXME: easily changeable keys should have lower weight - response_text and similar
  my $count = uniq (keys %$sig1, keys %$sig2);
  my $matchscore = 10;
  my $perfectmatch = 100;
  my $score = 0;

  foreach my $key (uniq (keys %$sig1, keys %$sig2))
  {
    if ( exists $sig1->{$key} and
         exists $sig2->{$key} and
         $sig1->{$key} eq $sig2->{$key})
    {
      $score+=$matchscore;
    }
    elsif ( exists $sig1->{$key} and
            exists $sig2->{$key} and
            $key =~ 'order' )
    {
      my @order1 = split(',', $sig1->{$key});
      my @order2 = split(',', $sig2->{$key});

      for (my $x=0; $x < ($#order1+1); $x++)
      {
	my $keymatched = 0;
        for (my $y=0; $y < ($#order2+1); $y++)
        {
	  if ($order1[$x] eq $order2[$y])
          {
            $keymatched = 1;
#            print "match! $order1[$x] eq $order2[$y]\n";
          }
        }
        if ($keymatched == 0)
        {
#          print "no match! removing $order1[$x] from " . join (',',@order1) . "\n";
          splice(@order1, $x, 1); # didn't find header x in sig2, delete from sig1
          $x--;
        }
#        print '@order1 = ' . join (',',@order1) . "\n";
#        print '@order2 = ' . join (',',@order2) . "\n";
      }
      # testresult is a ordered superset of the signature
      if (join (',',@order1) eq $sig2->{$key})
      {
        $score+=($matchscore * 3 / 4);
        print ("$sig1->{$key} superset of $sig2->{$key}\n") if ($debug and $debug >= 2);
        next;
      }

      my @order3 = split(',', $sig1->{$key}); # refresh @order1 to check for subsets properly
      for (my $x=0; $x < ($#order2+1); $x++)
      {
	my $keymatched = 0;
        for (my $y=0; $y < ($#order3+1); $y++)
        {
	  if ($order2[$x] eq $order3[$y])
          {
            $keymatched = 1;
#            print "match! $order2[$x] eq $order3[$y]\n";
          }
        }
        if ($keymatched == 0)
        {
#          print "no match! removing $order2[$x] from " . join (',',@order2) . "\n";
          splice(@order2, $x, 1); # didn't find header x in sig1, delete from sig2
          $x--;
        }
#        print '@order3 = ' . join(',',@order3) . "\n";
#        print '@order2 = ' . join(',',@order2) . "\n";
      }
      # testresult is a ordered subset of the signature
      if (join (',',@order2) eq $sig1->{$key})
      {
        $score+=($matchscore * 3 / 4);
        print ("$sig1->{$key} subset of $sig2->{$key}\n") if ($debug and $debug >= 2);;
        next;
      }

      # intersection of testresult and signature has more than one element, and same ordering - a bit weaker match
      if ( ($#order1+1) > 1 and join (',',@order2) eq join (',',@order1))
      {
        $score+=($matchscore / 2);
        print ("intersection " . join (',',@order2) . " of $sig1->{$key} and $sig2->{$key} has same order\n") if ($debug and $debug >= 2);;
        next;
      }

#      print "$sig1->{$key} and $sig2->{$key} does not match.\n";
    }
  }

  return floor ($score * $perfectmatch / ($matchscore * $count));
}

## THE ACTUAL TESTS
##############################

sub test_get_09_knowngood()
{
  # tests a 1991-style "GET /" request
  # we get lots of fun, illuminating responses to this one these days...
  # my favourite so far is the wonderful oxymoron "HTTP/0.9 200 OK"

  my $request   = "GET $path\r\n";
  my $request2  = "GET $path\r\n\r\n";

  if ($debug) { print "test_get_09_knowngood() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if ($#data == -1)
  {
    %signature = () ;
    @data = helper_talk($request2, $sigref);
    unless ($#data == -1)
    {
      $signature{'http09_needcrlfcrlf'} = 1;
    }
  }

  unless ($#data == -1)
  {
    if ($debug) {
      print "test_get_09_knowngood returned data (if any):\n" ;
      foreach (join '',@data) {
        print "$_\n";
      }
    }

    my $sigref2 = classify_signature(@data);
    my @sig2keys = keys %$sigref2;

    # irrelevant for http/0.9, false positive
    if (exists $sigref2->{'http_response_as_html'})
    {
      delete $sigref2->{'http_response_as_html'};
      delete $sigref2->{'response_code'};
      delete $sigref2->{'response_text'};
      @sig2keys = ( );
    }

    if ($#sig2keys > -1)
    {
      $signature{'http09_returnsheaders'} = 1;
      %signature = ( %signature, %$sigref2 );
    }
    else { $signature{'http09_valid'} = 1; }
  }

  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http_unexpected_keepalive'} = 1;
  }
  return $sigref;
}

sub is_namevhost()
{
  # XXX: implement me
  # tests HTTP/1.0 request with and without host header, compares returned data
}

sub test_get_10_knowngood()
{
  # tests a plain HTTP/1.0 request with Host header and a bland User-Agent.
  # no Accept: headers, in order to see default values.
  my $request  = "GET $path HTTP/1.0\r\n";
     $request .= "Host: $host\r\n";
     $request .= "User-Agent: $bland_useragent\r\n";
     $request .= "\r\n";

  if ($debug) { print "test_get_10_knowngood() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if (exists $signature{'connection_closed'})
  {
    # this basic a request really ought to work, but
    # I've seen fun threading bugs in unstable servers - so try again
    delete $signature{'connection_closed'};
    @data = helper_talk($request, $sigref);
  }

  if ($debug and @data) {
    print "test_get_10_knowngood() returned data (if any):\n" ;
    foreach (join '',@data) {
      print "$_\n";
    }
  }
  my $sigref2 = classify_signature(@data);
  %signature = ( %signature, %$sigref2 );
  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http_unexpected_keepalive'} = 1;
  }
  if (   (exists $signature{'response_code'} and $signature{'response_code'} != "200")
      or  exists $signature{'connection_refused'} )
  {
    print STDERR "The web server isn't responding politely to a plain HTTP/1.0 GET request.\n";
    print STDERR "Signature matching and generation won't work reliably - bailing out.\n";
    exit(1);
  }
  return $sigref;
}

sub test_get_11_knowngood()
{
  # tests a plain HTTP/1.1 request with Host header and a bland User-Agent.
  # no Accept: headers, in order to see default values.
  # Connection: close, for convenience.
  my $request  = "GET $path HTTP/1.1\r\n";
     $request .= "Host: $host\r\n";
     $request .= "User-Agent: $bland_useragent\r\n";
     $request .= "Connection: close\r\n";
     $request .= "\r\n";

  if ($debug) { print "test_get_11_knowngood() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if ($debug and @data) {
    print "test_get_11_knowngood() returned data (if any):\n" ;
    foreach (join '',@data) {
      print "$_\n";
    }
  }
  my $sigref2 = classify_signature(@data);
  %signature = ( %signature, %$sigref2 );
  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http11_ignores_connection_close'} = 1;
  }
  return $sigref;
}

sub test_get_11_headercontinuation_kind()
{
  # HTTP/1.1 fun with header continuation,
  # i.e. "\r\n\t" in the middle of header values
  # (being deprecated in current w3c httpbis)
  # also allowed, but discouraged, in HTTP/1.0 (RFC1945 section 2.2)

  # kind variant - folds User-Agent header
  my $request  = "GET $path HTTP/1.1\r\n";
     $request .= "Host: $host\r\n";
     $request .= "Connection: close\r\n";
     $request .= "User-Agent:\r\n\t$bland_useragent\r\n";
     $request .= "\r\n";

  if ($debug) { print "test_get_11_headercontinuation_kind() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if ($debug and @data) {
    print "test_get_11_headercontinuation_kind() returned data (if any):\n" ;
    foreach (join '',@data) {
      print "$_\n";
    }
  }
  my $sigref2 = classify_signature(@data);
  %signature = ( %signature, %$sigref2 );
  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http11_ignores_connection_close'} = 1;
  }
  return $sigref;
}

sub test_get_11_headercontinuation()
{
  # HTTP/1.1 fun with header continuation,
  # i.e. "\r\n\t" in the middle of header values
  # (being deprecated in current w3c httpbis)
  # also allowed, but discouraged, in HTTP/1.0 (RFC1945 section 2.2)

  # less kind variant - folds Host header, very likely to break
  my $request  = "GET $path HTTP/1.1\r\n";
     $request .= "Host:\r\n\t$host\r\n";
     $request .= "User-Agent: $bland_useragent\r\n";
     $request .= "Connection: close\r\n";
     $request .= "\r\n";

  if ($debug) { print "test_get_11_headercontinuation() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if ($debug and @data) {
    print "test_get_11_headercontinuation() returned data (if any):\n" ;
    foreach (join '',@data) {
      print "$_\n";
    }
  }
  my $sigref2 = classify_signature(@data);
  %signature = ( %signature, %$sigref2 );
  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http11_ignores_connection_close'} = 1;
  }
  return $sigref;
}

sub test_options_11_star()
{
  # HTTP/1.1 OPTIONS request applicable for whole server
  my $request  = "OPTIONS * HTTP/1.1\r\n";
     $request .= "Host: $host\r\n";
     $request .= "User-Agent: $bland_useragent\r\n";
     $request .= "Connection: close\r\n";
     $request .= "\r\n";

  if ($debug) { print "test_options_11_star() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if ($debug and @data) {
    print "test_options_11_star() returned data (if any):\n" ;
    foreach (join '',@data) {
      print "$_\n";
    }
  }
  my $sigref2 = classify_signature(@data);
  %signature = ( %signature, %$sigref2 );
  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http11_ignores_connection_close'} = 1;
  }
  return $sigref;
}

sub test_options_11_knowngood()
{
  # HTTP/1.1 OPTIONS request applicable for the known good url
  my $request  = "OPTIONS $path HTTP/1.1\r\n";
     $request .= "Host: $host\r\n";
     $request .= "User-Agent: $bland_useragent\r\n";
     $request .= "Connection: close\r\n";
     $request .= "\r\n";

  if ($debug) { print "test_options_11_knowngood() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if ($debug and @data) {
    print "test_options_11_knowngood() returned data (if any):\n" ;
    foreach (join '',@data) {
      print "$_\n";
    }
  }
  my $sigref2 = classify_signature(@data);
  %signature = ( %signature, %$sigref2 );
  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http11_ignores_connection_close'} = 1;
  }
  return $sigref;
}

sub test_get_12_knowngood()
{
  # test_get_11_knowngood() with http version changed to 1.2, to test handling of unknown minor http versions
  #  some servers fall back to talking 1.1, some to 1.0
  my $request  = "GET $path HTTP/1.2\r\n";
     $request .= "Host: $host\r\n";
     $request .= "User-Agent: $bland_useragent\r\n";
     $request .= "Connection: close\r\n";
     $request .= "\r\n";

  if ($debug) { print "test_get_12_knowngood() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if ($debug and @data) {
    print "test_get_12_knowngood() returned data (if any):\n" ;
    foreach (join '',@data) {
      print "$_\n";
    }
  }
  my $sigref2 = classify_signature(@data);
  %signature = ( %signature, %$sigref2 );
  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http11_ignores_connection_close'} = 1;
  }
  return $sigref;
}

sub test_doesnotexist_11_knowngood()
{
  # HTTP/1.1 guaranteed non-existent method request for the known good url.
  # some simple implementations treat it as a GET and doesn't worry further.
  my $request  = "DOESNOTEXIST $path HTTP/1.1\r\n";
     $request .= "Host: $host\r\n";
     $request .= "User-Agent: $bland_useragent\r\n";
     $request .= "Connection: close\r\n";
     $request .= "\r\n";

  if ($debug) { print "test_doesnotexist_11_knowngood() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if ($debug and @data) {
    print "test_doesnotexist_11_knowngood() returned data (if any):\n" ;
    foreach (join '',@data) {
      print "$_\n";
    }
  }
  my $sigref2 = classify_signature(@data);
  %signature = ( %signature, %$sigref2 );
  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http11_ignores_connection_close'} = 1;
  }
  return $sigref;
}

sub test_hairy_method_11_knowngood()
{
  # HTTP/1.1 guaranteed non-existent method request for the known good url.
  # nginx had a behaviour change on methods with _ in them at some point.
  my $request  = "HAIRY_METHOD $path HTTP/1.1\r\n";
     $request .= "Host: $host\r\n";
     $request .= "User-Agent: $bland_useragent\r\n";
     $request .= "Connection: close\r\n";
     $request .= "\r\n";

  if ($debug) { print "test_hairy_method_11_knowngood() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if ($debug and @data) {
    print "test_hairy_method_11_knowngood() returned data (if any):\n" ;
    foreach (join '',@data) {
      print "$_\n";
    }
  }
  my $sigref2 = classify_signature(@data);
  %signature = ( %signature, %$sigref2 );
  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http11_ignores_connection_close'} = 1;
  }
  return $sigref;
}

sub test_get_20_knowngood()
{
  # test_get_11_knowngood() with http version changed to 2.0, to test handling of unknown major http versions
  my $request  = "GET $path HTTP/2.0\r\n";
     $request .= "Host: $host\r\n";
     $request .= "User-Agent: $bland_useragent\r\n";
     $request .= "Connection: close\r\n";
     $request .= "\r\n";

  if ($debug) { print "test_get_20_knowngood() starting\n"; }

  my %signature ;
  my $sigref = \%signature ;

  my @data = helper_talk($request, $sigref);

  if ($debug and @data) {
    print "test_get_20_knowngood() returned data (if any):\n" ;
    foreach (join '',@data) {
      print "$_\n";
    }
  }
  my $sigref2 = classify_signature(@data);
  %signature = ( %signature, %$sigref2 );
  if (exists $signature{'does_keepalive'})
  {
    delete $signature{'does_keepalive'};
    $signature{'http_unexpected_keepalive'} = 1;
  }
  return $sigref;
}

## test helpers
#############################

# helper, opening/closing connection and doing non-blocking i/o
sub helper_talk
{
  my @data;
  my $blarg;
  my $amountread;
  my $sigref = $_[1] ;
 
  use IO::Socket;
  my $sock = new IO::Socket::INET ( PeerAddr => $host, PeerPort => $port, Proto => 'tcp' );

  unless ($sock)
  {
    print STDERR "Could not create socket: $!\n" if $verbose;
    $sigref->{'connection_refused'} = 1;
    return @data;
  }
  
  $sock->blocking(0);

  print $sock $_[0];

  my $rin = '';
  vec($rin,fileno($sock),1) = 1;

  my ($nfound,$timeleft) = select(my $rout=$rin, undef, undef, $mediumtimeout);

  # slow reply? timeout, perhaps?
  if ($nfound and ($timeleft < ($mediumtimeout / 2)))
  {
    $sigref->{'delayed_reply'} = floor($mediumtimeout - $timeleft);
  }

  if ($nfound)
  {
    # $amountread = undef means connection closed during the select, or similar.
    while ($nfound and $amountread = read $sock, $blarg, 5000000)
    {
      push @data, $blarg;
      vec($rin,fileno($sock),1) = 1;
      ($nfound,$timeleft) = select(my $rout=$rin, undef, undef, $mediumtimeout);
    }
    if (defined $amountread and $amountread == 0)
    {
      # controlled connection close straightaway after the last of the data -
      # reset timeleft to avoid triggering delayed_close
      $timeleft = $mediumtimeout;
    }
  };

  unless ($nfound)
  {
    $sigref->{'does_keepalive'} = 1; # which is mostly unexpected for our tests.
  }

  # connection slow to close?
  if ($nfound and (not defined ($amountread) or $amountread < 1) and ($timeleft < ($mediumtimeout / 2)))
  {
    $sigref->{'delayed_close'} = floor($mediumtimeout - $timeleft);
  }

  close($sock);

  if ($#data == -1) { $sigref->{'connection_closed'} = 1; }

  return @data;
}

## the meaty big classification routine
##############################################

sub classify_signature()
{
  my @data = (@_) ;
  my @lines;
  my %signature ;
  my $sigref = \%signature ;
  my $linenum = 0 ;
  my @headers;

  unless (defined $data[0]) { return $sigref; }

  @data = ( join '', @data );

  while (@data)
  {
    my @tmp = split /\n/, pop @data ;
    @lines = (@lines, @tmp) ;
  }

  # preprocessing: do header line folding, cut everything after the header
  my @linestmp;
  LINEPRE: foreach my $line (@lines)
  {
    my $tmp = $/ ;
    $/ = "\r" ;
    chomp $line ;
    $/ = $tmp ;

    if (($#linestmp > -1) and $line =~ /^\s+(\S+.+)/)
    {
      print "classify preprocessing: folding line '$1' into previous '$linestmp[$#linestmp]'\n" if $debug;
      $linestmp[$#linestmp] = $linestmp[$#linestmp] . $1 ;
      next;
    }

    if ($#linestmp > 0 and $line =~ /^$/)
    {
      last LINEPRE; # crlfcrlf - end of headers
    }
    push @linestmp, $line;
  }
  @lines = @linestmp ;

  # analysis
  LINE: foreach my $line (@lines)
  {
    $linenum++;

    # check for overeager 100 Continue ... sent after seeing the request line and before seeing the headers.
    # Jetty 2.4 does this. It then reads the headers, and follows up sending a full response.
    # A quite strange interpretation of RFC2068.
    if ($line =~ m|^([Hh][Tt][Tt][Pp])/(1\.1) 100| and not exists $signature{'http'} and not exists $signature{'temp_http'})
    {
      $signature{'temp_http'} = $1;
      $signature{'temp_http_version'} = $2;

      if ($line =~ m|^[Hh][Tt][Tt][Pp]/\d\.\d(\s+)(\d{3})(\s+)(.+)| )
      {
        $signature{'temp_response_code'} = $2;
        $signature{'temp_response_text'} = $4;
        unless ($1 eq " ") { $signature{'temp_quirk_http_to_responsecode_whitespace'} = $1; }
        unless ($3 eq " ") { $signature{'temp_quirk_responsecode_to_responsetext_whitespace'} = $3; }
      }
      next LINE;
    }

    # Don't look too hard - shortcircuit if we see <HTML>
    if ( not exists $signature{'http'} and
         (   $line =~ m|(^<[Hh][Tt][Mm][Ll]>)|
          or $line =~ m|(^<?[Xx][Mm][Ll])|
          or $line =~ m|(^<!--)|
          or $line =~ m|(^<![Dd][Oo][Cc][Tt][Yy][Pp][Ee])|
         )
       )
    {
      print "shortcircuit: found $1 before any HTTP response\n" if $debug;
      last LINE;
    }

    # look for the http response
    if ($line =~ m|^([Hh][Tt][Tt][Pp])/(\d\.\d)| and not exists $signature{'http'})
    {
      $signature{'http'} = $1;
      $signature{'http_version'} = $2;

      if ($line =~ m|^[Hh][Tt][Tt][Pp]/\d\.\d(\s+)(\d{3})(\s+)(.+)| )
      {
        $signature{'response_code'} = $2;
        $signature{'response_text'} = $4;
        unless ($1 eq " ") { $signature{'quirk_http_to_responsecode_whitespace'} = $1; }
        unless ($3 eq " ") { $signature{'quirk_responsecode_to_responsetext_whitespace'} = $3; }
      }
    }

    if ($linenum == 1 and not exists $signature{'http'} and not exists $signature{'temp_http'} and $line =~ m|^\s*$|)
    {
      $signature{'quirk_whitespace_before_http_response'} = 1;
      next LINE;
    }

    # read headers
    if ($line =~ /^(\S+)( ?):( ?)(.*)/)
    {
      my $hname = $1 ;
      my $hcontent = $4 ;
      push @headers, $hname ;
      unless ($2 eq "") {
        my $quirkname = 'quirk_whitespace_pre_' . lc ($1);
        $signature{$quirkname} = hex $2 ;
      }
      unless ($3 eq " ") {
        my $quirkname = 'quirk_whitespace_post_' . lc ($1);
        $signature{$quirkname} = hex $3 ;
      }
      if ($hname =~ m|^Allow$|i)
      {
        my @tmp = split ( / |,/, $hcontent ) ;
        $signature{'allow_order'} = uc join ",", grep { ! m|^$| } @tmp ;
      }
      # public (order) arrived in rfc2068, just long enough to shanghai rtsp/1.0, then
      # disappeared from the revised http/1.1 specification rfc2616 just two years later.
      if ($hname =~ m|^Public$|i)
      {
        my @tmp = split ( / |,/, $hcontent ) ;
        $signature{'public_order'} = uc join ",", grep { ! m|^$| } @tmp ;
      }
      # if we get something weird in Accept-Ranges, record it ... say 'mail' or 'records' or something.
      if ($hname =~ m|^Accept-Ranges$|i)
      {
        if ($hcontent ne 'bytes')
        {
          $signature{'accept_ranges'} = $hcontent ;
        }
      }
    }
  }

  # list header order
  #  ignore X-* headers, Set-Cookie, SLASH-LOG-DATA, Content-Disposition, Content-Language
  if (@headers) {
    $signature{'header_order'} = join(',', grep { (!/^X-.*/i and !/^Set-Cookie/i and !/^SLASH-LOG-DATA/i and !/^Content-Disposition/i and !/^Content-Language/i) } @headers) ;
  }

  # overeager 100 Continue quirk
  if (exists $signature{'temp_http_version'} and exists $signature{'http_version'})
  {
    $signature{'overeager_100_continue'} = 1;
    delete $signature{'temp_http'};
    delete $signature{'temp_http_version'};
    delete $signature{'temp_response_code'};
    delete $signature{'temp_response_text'};
    delete $signature{'temp_quirk_http_to_responsecode_whitespace'};
    delete $signature{'temp_quirk_responsecode_to_responsetext_whitespace'};
  }

  # did we really get just a 100 Continue? All right.
  if (exists $signature{'temp_http_version'} and not exists $signature{'http_version'})
  {
    $signature{'http'}             = $signature{'temp_http'};          delete $signature{'temp_http'};
    $signature{'http_version'}     = $signature{'temp_http_version'};  delete $signature{'temp_http_version'};
    $signature{'response_code'}    = $signature{'temp_response_code'}; delete $signature{'temp_response_code'};
    $signature{'response_text'}    = $signature{'temp_response_text'}; delete $signature{'temp_response_text'};
    if ( exists $signature{'temp_quirk_http_to_responsecode_whitespace'} )
    {
      $signature{'quirk_http_to_responsecode_whitespace'} = $signature{'temp_quirk_http_to_responsecode_whitespace'}; delete $signature{'temp_quirk_http_to_responsecode_whitespace'};
    }
    if ( exists $signature{'temp_quirk_responsecode_to_responsetext_whitespace'} )
    {
      $signature{'quirk_responsecode_to_responsetext_whitespace'} = $signature{'temp_quirk_responsecode_to_responsetext_whitespace'}; delete $signature{'temp_quirk_responsecode_to_responsetext_whitespace'};
    }
  }

  if (exists $signature{'http'} and $signature{'http'} eq 'HTTP')
  {
    # this is the default case, no need to record it. If it's lowercase or RTSP or something, however, keep it...
    delete $signature{'http'};
  }

  # no http response found at all?
  # expected, for HTTP/0.9
  # mildly unexpected otherwise
  unless (exists $signature{'http_version'})
  {
    delete $signature{'quirk_whitespace_before_http_response'}; # we didn't get any http response after all, so this is bogus
    # grope through the data looking for error codes.
    # the server may have sent a html error page with the http response embedded.
    # some boa releases do this
    FALLBACKLINE: foreach my $line (grep { m|<.+?>\d{3}.*</.+?>| } @lines)
    {
      if ($line =~ m|<.+?>(\d{3})\s*(.+?)</.+?>|)
      {
         $signature{'response_code'} = $1;
         $signature{'response_text'} = $2;
         $signature{'http_response_as_html'} = 1;
         last FALLBACKLINE;
      }
    }
  }

  return $sigref;
}

